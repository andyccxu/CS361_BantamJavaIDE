/*
 * File: Parser.java
 * Authors: Haoyu Song and Dale Skrien
 * Latest change: Oct. 5, 2021
 *
 * In the grammar below, the variables are enclosed in angle brackets and
 * "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable
 * (but note that "||" is an operator).
 * EMPTY indicates a rule with an empty right hand side.
 * All other symbols in the rules are terminals.
 *
 * Group members: Ricky Peng, Andy Xu, Alex Yu
 * CS 361 Project 9
 * Date: April 24, 2022
 */
package proj10PengXuYu.bantam.parser;

import proj10PengXuYu.bantam.ast.*;
import proj10PengXuYu.bantam.lexer.Scanner;
import proj10PengXuYu.bantam.lexer.Token;
import proj10PengXuYu.bantam.treedrawer.Drawer;
import proj10PengXuYu.bantam.util.CompilationException;
import proj10PengXuYu.bantam.util.Error;
import proj10PengXuYu.bantam.util.ErrorHandler;


public class Parser
{
    // instance variables
    private Scanner scanner; // provides the tokens
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler; // collects & organizes the error messages

    private String filename; // the filename of the Bantam Java file to be parsed.

    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }

    /**
     * parse the given file and return the root node of the AST
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) {
        this.filename = filename;
        scanner = new Scanner(filename, errorHandler);
        currentToken = scanner.scan();
        Program root = parseProgram();
        return root;
    }


    // <Program> ::= <Class> | <Class> <Program>
    private Program parseProgram() {
        int position = currentToken.position;
        ClassList clist = new ClassList(position);

        while (currentToken.kind != Token.Kind.EOF) {
            Class_ aClass = parseClass();
            clist.addElement(aClass);
        }

        return new Program(position, clist);
    }


    // <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
    // <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
    // <MemberList> ::= EMPTY | <Member> <MemberList>
    private Class_ parseClass() {

        int position = currentToken.position;
        String className;
        String parent = null;
        MemberList memberList = new MemberList(position);

        if (currentToken.kind != Token.Kind.CLASS) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Class should start with a \"class\" keyword.");
            throw new CompilationException(errorHandler);
        }
        else {
            currentToken = scanner.scan();
            className = parseIdentifier();
            // <ExtendsClause>
            if (currentToken.kind == Token.Kind.EXTENDS) {
                currentToken = scanner.scan();
                parent = parseIdentifier();
            }
            else {
                parent = "Object";
            }
            // { <MemberList> }
            if (currentToken.kind == Token.Kind.LCURLY) {
                currentToken = scanner.scan();
                while (currentToken.kind != Token.Kind.RCURLY) {
                    Member member = parseMember();
                    memberList.addElement(member);
                }
            } else {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Missing curly brace after the class name.");
                throw new CompilationException(errorHandler);
            }
        }
        currentToken = scanner.scan();
        return new Class_(position, filename, className, parent, memberList);
    }


    //Fields and Methods
    // <Member> ::= <Field> | <Method>
    // <Method> ::= <Type> <Identifier> ( <Parameters> ) <BlockStmt>
    // <Field> ::= <Type> <Identifier> <InitialValue> ;
    // <InitialValue> ::= EMPTY | = <Expression>
    private Member parseMember() {
        int position = currentToken.position;
        String type  = parseType();
        String identifier = parseIdentifier();
        // methods
        if (currentToken.kind == Token.Kind.LPAREN) {
            currentToken = scanner.scan();
            FormalList pars = parseParameters();
            if (currentToken.kind != Token.Kind.RPAREN) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Missing right parenthesis.");
                throw new CompilationException(errorHandler);
            }
            currentToken = scanner.scan();
            if (currentToken.kind != Token.Kind.LCURLY) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Missing left curly braces.");
                throw new CompilationException(errorHandler);
            }
            BlockStmt stmt = (BlockStmt) parseBlock();
            StmtList stmtList = stmt.getStmtList();
            return new Method(position, type, identifier, pars, stmtList);
        }
        // fields
        else {
            Expr expr = null;
            // no initial value
            if (currentToken.kind != Token.Kind.SEMICOLON) {
                if (currentToken.kind != Token.Kind.ASSIGN) {
                    errorHandler.register(Error.Kind.PARSE_ERROR,
                            filename,
                            position,
                            "Invalid field declaration.");
                    throw new CompilationException(errorHandler);
                } else {
                    currentToken = scanner.scan();
                    expr = parseExpression();
                    if (currentToken.kind != Token.Kind.SEMICOLON) {
                        errorHandler.register(Error.Kind.PARSE_ERROR,
                                filename,
                                position,
                                "Missing semicolon at the end of field declaration.");
                        throw new CompilationException(errorHandler);
                    }
                }
            }
            currentToken = scanner.scan();
            return new Field(position, type, identifier, expr);
        }
    }


    //-----------------------------------
    //Statements
    // <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <VarDeclaration>
    //             | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
    private Stmt parseStatement() {
        Stmt stmt;

        switch (currentToken.kind) {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseVarDeclaration();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }

        return stmt;
    }


    // <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
    private Stmt parseWhile() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.LPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Missing left parenthesis before the while condition.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        Expr expr = parseExpression();
        if (currentToken.kind != Token.Kind.RPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Missing right parenthesis after the while condition.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        Stmt bodyStmt = parseStatement();
        return new WhileStmt(position, expr, bodyStmt);
    }


    // <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
    private Stmt parseReturn() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        Expr expr = null;
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            expr = parseExpression();
            if (currentToken.kind != Token.Kind.SEMICOLON) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Invalid return statement.");
                throw new CompilationException(errorHandler);
            }
        }
        currentToken = scanner.scan();
        return new ReturnStmt(position, expr);
    }


    // <BreakStmt> ::= BREAK ;
    private Stmt parseBreak() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid break statement.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        return new BreakStmt(position);
    }


    // <ExpressionStmt> ::= <Expression> ;
    private ExprStmt parseExpressionStmt() {
        int position = currentToken.position;
        Expr expr = parseExpression();
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid expression statement.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        return new ExprStmt(position, expr);
    }


    // <VarDeclaration> ::= VAR <Id> = <Expression> ;
    // Every local variable must be initialized
    private Stmt parseVarDeclaration() {
        int position = currentToken.position;
        // parse <Id>
        currentToken = scanner.scan();
        String identifier = parseIdentifier();
        // parse "="
        if (currentToken.kind != Token.Kind.ASSIGN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid variable declaration: Assignment symbol missing.");
            throw new CompilationException(errorHandler);
        }
        // parse <Expression>
        currentToken = scanner.scan();
        Expr expression = parseExpression();
        // parse ";"
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid variable declaration: Semicolon missing.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        return new DeclStmt(position, identifier, expression);
    }


    // <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
    // <Start> ::=     EMPTY | <Expression>
    // <Terminate> ::= EMPTY | <Expression>
    // <Increment> ::= EMPTY | <Expression>
    private Stmt parseFor() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.LPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Missing parenthesis after keyword \"for\".");
            throw new CompilationException(errorHandler);
        }
        Expr start = null;
        Expr terminate = null;
        Expr increment = null;
        // parse <Start>;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            start = parseExpression();
            if (currentToken.kind != Token.Kind.SEMICOLON) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Invalid for loop start condition expression.");
                throw new CompilationException(errorHandler);
            }
        }
        // parse <Terminate>;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.SEMICOLON) {
            terminate = parseExpression();
            if (currentToken.kind != Token.Kind.SEMICOLON) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Invalid for loop terminate condition expression.");
                throw new CompilationException(errorHandler);
            }
        }
        // parse <Increment> )
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.RPAREN) {
            increment = parseExpression();
            if (currentToken.kind != Token.Kind.RPAREN) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Invalid for loop condition expression: Missing right parenthesis.");
                throw new CompilationException(errorHandler);
            }
        }
        // parse <Stmt>
        currentToken = scanner.scan();
        Stmt bodyStmt = parseStatement();
        return new ForStmt(position, start, terminate, increment, bodyStmt);
    }


    // <BlockStmt> ::= { <Body> }
    // <Body> ::= EMPTY | <Stmt> <Body>
    private Stmt parseBlock() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        StmtList list = new StmtList(currentToken.position);
        while (currentToken.kind != Token.Kind.RCURLY) {
            Stmt stmt = parseStatement();
            list.addElement(stmt);
        }
        currentToken = scanner.scan();
        return new BlockStmt(position, list);
    }


    // <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
    private Stmt parseIf() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.LPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Missing left parenthesis after keyword \"if\".");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        Expr predExpr = parseExpression();
        if (currentToken.kind != Token.Kind.RPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Missing right parenthesis after keyword \"if\".");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        Stmt thenStmt = parseStatement();
        Stmt elseStmt = null;
        if (currentToken.kind == Token.Kind.ELSE) {
            currentToken = scanner.scan();
            elseStmt = parseStatement();
        }
        return new IfStmt(position, predExpr, thenStmt, elseStmt);
    }


    //-----------------------------------------
    // Expressions
    // Here we use different rules than the grammar on page 49
    // of the manual to handle the precedence of operations

    // <Expression> ::= <LogicalORExpr> <OptionalAssignment>
    // <OptionalAssignment> ::= EMPTY | = <Expression>
    private Expr parseExpression() {
        int position = currentToken.position;
        Expr expr = parseOrExpr();
        if (currentToken.kind == Token.Kind.ASSIGN && expr instanceof VarExpr) {
            currentToken = scanner.scan();
            Expr right = parseExpression();
            return new AssignExpr(position, null, ((VarExpr) expr).getName(), right);
        } else {
            return expr;
        }
    }


    // <LogicalOR> ::= <logicalAND> <LogicalORRest>
    // <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
    private Expr parseOrExpr() {
        int position = currentToken.position;
        Expr left;

        left = parseAndExpr();
        while (currentToken.spelling.equals("||")) {
            //...advance to the next token...
            // ? I think we need scanner.scan() here
            currentToken = scanner.scan();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(position, left, right);
        }

        return left;
    }


    // <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
    // <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
    private Expr parseAndExpr() {
        int position = currentToken.position;
        Expr left;

        left = parseEqualityExpr();
        while (currentToken.spelling.equals("&&")) {
            currentToken = scanner.scan();
            Expr right = parseEqualityExpr();
            left = new BinaryLogicAndExpr(position, left, right);
        }

        return left;
    }


    // <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
    //                      <RelationalExpr>
    // <equalOrNotEqual> ::=  == | !=
    private Expr parseEqualityExpr() {
        int position = currentToken.position;
        Expr left = parseRelationalExpr();
        if (currentToken.spelling.equals("==")) {
            currentToken = scanner.scan();
            Expr right = parseRelationalExpr();
            return new BinaryCompEqExpr(position, left, right);
        }
        else if (currentToken.spelling.equals("!=")) {
            currentToken = scanner.scan();
            Expr right = parseRelationalExpr();
            return new BinaryCompNeExpr(position, left, right);
        }
        else {
            return left;
        }
    }


    // <RelationalExpr> ::= <AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
    // <ComparisonOp> ::= < | > | <= | >=
    // <ComparisonOp> ::= instanceof
    private Expr parseRelationalExpr() {
        int position = currentToken.position;
        Expr left = parseAddExpr();
        Expr right;
        if (currentToken.spelling.equals("<")) {
            currentToken = scanner.scan();
            right = parseAddExpr();
            return new BinaryCompLtExpr(position, left, right);
        }
        else if (currentToken.spelling.equals(">")) {
            currentToken = scanner.scan();
            right = parseAddExpr();
            return new BinaryCompGtExpr(position, left, right);
        }
        else if (currentToken.spelling.equals("<=")) {
            currentToken = scanner.scan();
            right = parseAddExpr();
            return new BinaryCompLeqExpr(position, left, right);
        }
        else if (currentToken.spelling.equals(">=")) {
            currentToken = scanner.scan();
            right = parseAddExpr();
            return new BinaryCompGeqExpr(position, left, right);
        }
        else if (currentToken.spelling.equals("instanceof")) {
            currentToken = scanner.scan();
            return new InstanceofExpr(position, left, parseType());
        }
        else {
            return left;
        }
    }


    // <AddExpr>::＝ <MultExpr> <MoreMultExpr>
    // <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
    private Expr parseAddExpr() {
        int position = currentToken.position;
        Expr left = parseMultExpr();
        Expr right;
        while (currentToken.spelling.equals("+") || currentToken.spelling.equals("-")) {
            boolean isPlus;
            if (currentToken.spelling.equals("+")) {
                isPlus = true;
            } else {
                isPlus = false;
            }
            currentToken = scanner.scan();
            right = parseMultExpr();
            if (isPlus) {
                left = new BinaryArithPlusExpr(position, left, right);
            } else {
                left = new BinaryArithMinusExpr(position, left, right);
            }
        }
//        currentToken = scanner.scan();
        return left;
    }


    // <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
    // <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
    //               / <NewCastOrUnary> <MoreNCU> |
    //               % <NewCastOrUnary> <MoreNCU> |
    //               EMPTY
    private Expr parseMultExpr() {
        int position = currentToken.position;
        Expr left = parseNewCastOrUnary();
        Expr right;
        while (currentToken.spelling.equals("*") || currentToken.spelling.equals("/")
                || currentToken.spelling.equals("%")) {
            boolean isMult = false;
            boolean isDiv = false;
            if (currentToken.spelling.equals("*")) {
                isMult = true;
            } else if (currentToken.spelling.equals("/")) {
                isDiv = true;
            }
            currentToken = scanner.scan();
            right = parseNewCastOrUnary();
            if (isMult) {
                left = new BinaryArithTimesExpr(position, left, right);
            } else if (isDiv) {
                left = new BinaryArithDivideExpr(position, left, right);
            } else {
                left = new BinaryArithModulusExpr(position, left, right);
            }
        }
        return left;
    }

    // <NewCastOrUnary> ::= <NewExpression> | <CastExpression> | <UnaryPrefix>
    private Expr parseNewCastOrUnary() {
        Expr expr;

        switch (currentToken.kind) {
            case NEW:
                expr = parseNew();
                break;
            case CAST:
                expr = parseCast();
                break;
            default:
                expr = parseUnaryPrefix();
        }

        return expr;
    }


    // <NewExpression> ::= NEW <Identifier> ( )
    private Expr parseNew() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        String type = parseIdentifier();
        if (currentToken.kind != Token.Kind.LPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid New Expression: Missing left parenthesis.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.RPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid New Expression.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        return new NewExpr(position, type);
    }


    // <CastExpression> ::= CAST ( <Type> , <Expression> )
    private Expr parseCast() {
        int position = currentToken.position;
        currentToken = scanner.scan();
        if (currentToken.kind != Token.Kind.LPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid Cast Expression: Missing left parenthesis.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        String type = parseType();
        if (currentToken.kind != Token.Kind.COMMA) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid Cast Expression: Missing comma");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        Expr expr = parseExpression();
        if (currentToken.kind != Token.Kind.RPAREN) {
            errorHandler.register(Error.Kind.PARSE_ERROR,
                    filename,
                    position,
                    "Invalid Cast Expression: Missing right parenthesis.");
            throw new CompilationException(errorHandler);
        }
        currentToken = scanner.scan();
        return new CastExpr(position, type, expr);
    }

    // ? grammar
    // <UnaryPrefix> ::= <PrefixOp> <UnaryPreFix> | <UnaryPostfix>
    // <PrefixOp> ::= - | ! | ++ | --
    private Expr parseUnaryPrefix() {
        int position = currentToken.position;
        Expr expr;
        Expr right;
        switch (currentToken.spelling) {
            case "-":
                currentToken = scanner.scan();
                right = parseUnaryPrefix();
                expr = new UnaryNegExpr(position, right);
                break;
            case "!":
                currentToken = scanner.scan();
                right = parseUnaryPrefix();
                expr = new UnaryNotExpr(position, right);
                break;
            case "++":
                currentToken = scanner.scan();
                right = parseUnaryPrefix();
                expr = new UnaryIncrExpr(position, right, false);
                break;
            case "--":
                currentToken = scanner.scan();
                right = parseUnaryPrefix();
                expr = new UnaryDecrExpr(position, right, false);
                break;
            default:
                expr = parseUnaryPostfix();
        }
        return expr;
    }


    // <UnaryPostfix> ::= <Primary> <PostfixOp>
    // <PostfixOp> ::= ++ | -- | EMPTY
    private Expr parseUnaryPostfix() {
        int position = currentToken.position;
        Expr primary = parsePrimary();
        if (currentToken.spelling.equals("++")) {
            currentToken = scanner.scan();
            return new UnaryIncrExpr(position, primary, true);
        } else if (currentToken.spelling.equals("--")) {
            currentToken = scanner.scan();
            return new UnaryDecrExpr(position, primary, true);
        } else {
            return primary;
        }
    }


    // <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
    //                              <StringConst> | <VarExpr>
    // <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
    // <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
    // <VarExprSuffix> ::= . <Identifier> ( <Arguments> ) | ( <Arguments>) | EMPTY
    private Expr parsePrimary() {
        int position = currentToken.position;
        Expr expr;

        switch (currentToken.kind) {
            case LPAREN:
                currentToken = scanner.scan();
                expr = parseExpression();
                if (currentToken.kind != Token.Kind.RPAREN) {
                    errorHandler.register(Error.Kind.PARSE_ERROR,
                            filename, position,
                            "Missing right parenthesis for the expression.");
                    throw new CompilationException(errorHandler);
                }
                currentToken = scanner.scan();
                break;
            case INTCONST:
                expr = parseIntConst();
                break;
            case BOOLEAN:
                expr = parseBoolean();
                break;
            case STRCONST:
                expr = parseStringConst();
                break;
            // <varExpr>
            default:
                Expr ref = null;
                String identifier;
                // "this"/"super" can either be the prefix or identifier
                if (currentToken.spelling.equals("super") ||
                        currentToken.spelling.equals("this")) {
                    identifier = currentToken.spelling;
                    currentToken = scanner.scan();
                    if (currentToken.kind == Token.Kind.DOT) {
                        ref = new VarExpr(position, null, identifier);
                        currentToken = scanner.scan();
                        identifier = parseIdentifier();
                    }
                } else {
                    // this means no prefix
                    identifier = parseIdentifier();
                }
                // handles suffix
                if (currentToken.kind == Token.Kind.LPAREN) {
                    currentToken = scanner.scan();
                    ExprList actualList = parseArguments();
                    if (currentToken.kind != Token.Kind.RPAREN) {
                        errorHandler.register(Error.Kind.PARSE_ERROR,
                                filename, position,
                                "Invalid dispatch expression: " +
                                        "missing right parenthesis.");
                        throw new CompilationException(errorHandler);
                    }
                    expr = new DispatchExpr(position, ref, identifier, actualList);
                    currentToken = scanner.scan();
                } else if (currentToken.kind == Token.Kind.DOT) {
                    ref = new VarExpr(position, null, identifier);
                    currentToken = scanner.scan();
                    identifier = parseIdentifier();
                    if (currentToken.kind == Token.Kind.LPAREN) {
                        currentToken = scanner.scan();
                        ExprList actualList = parseArguments();
                        if (currentToken.kind != Token.Kind.RPAREN) {
                            errorHandler.register(Error.Kind.PARSE_ERROR,
                                    filename, position,
                                    "Invalid dispatch expression: " +
                                            "missing right parenthesis.");
                            throw new CompilationException(errorHandler);
                        }
                        expr = new DispatchExpr(position, ref, identifier, actualList);
                        currentToken = scanner.scan();
                    } else {
                        errorHandler.register(Error.Kind.PARSE_ERROR,
                                filename, position,
                                "Invalid dispatch expression: " +
                                        "missing left parentheses.");
                        throw new CompilationException(errorHandler);
                    }
                } else {
                    // this means no suffix
                    expr = new VarExpr(position, ref, identifier);
                }
        }
        return expr;
    }



    // <Arguments> ::= EMPTY | <Expression> <MoreArgs>
    // <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
    private ExprList parseArguments() {
        int position = currentToken.position;
        ExprList exprs = new ExprList(position);
        while (currentToken.kind != Token.Kind.RPAREN) {
            Expr expr = parseExpression();
            exprs.addElement(expr);
            if (currentToken.kind == Token.Kind.COMMA) {
                currentToken = scanner.scan();
            } else if (currentToken.kind != Token.Kind.RPAREN) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Invalid arguments list.");
                throw new CompilationException(errorHandler);
            }
        }
        return exprs;
    }


    // <Parameters> ::=  EMPTY | <Formal> <MoreFormals>
    // <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
    private FormalList parseParameters() {
        int position = currentToken.position;
        FormalList pars = new FormalList(position);
        while (currentToken.kind != Token.Kind.RPAREN) {
            Formal formal = parseFormal();
            pars.addElement(formal);
            if (currentToken.kind == Token.Kind.COMMA) {
                currentToken = scanner.scan();
            } else if (currentToken.kind != Token.Kind.RPAREN) {
                errorHandler.register(Error.Kind.PARSE_ERROR,
                        filename,
                        position,
                        "Invalid parameters list.");
                throw new CompilationException(errorHandler);
            }
        }
        return pars;
    }

    // <Formal> ::= <Type> <Identifier>
    private Formal parseFormal() {
        int position = currentToken.position;
        String type = parseType();
        String name = parseIdentifier();
        return new Formal(position, type, name);
    }


    // <Type> ::= <Identifier>
    private String parseType() {
        return parseIdentifier();
    }


    //----------------------------------------
    //Terminals

    private String parseOperator() {
        String operator = currentToken.spelling;
        currentToken = scanner.scan();
        return operator;
    }


    private String parseIdentifier() {
        String identifier = currentToken.spelling;
        currentToken = scanner.scan();
        return identifier;
    }


    private ConstStringExpr parseStringConst() {
        //...save the currentToken's string to a local variable...
        //...advance to the next token...
        //...return a new ConstStringExpr containing the string...
        int position = currentToken.position;
        String constant = currentToken.spelling;
        currentToken = scanner.scan();
        return new ConstStringExpr(position, constant);
    }


    private ConstIntExpr parseIntConst() {
        int position = currentToken.position;
        String constant = currentToken.spelling;
        currentToken = scanner.scan();
        return new ConstIntExpr(position, constant);
    }


    private ConstBooleanExpr parseBoolean() {
        int position = currentToken.position;
        String constant = currentToken.spelling;
        currentToken = scanner.scan();
        return new ConstBooleanExpr(position, constant);
    }



    /**
     * Main method created for testing purposes.
     */
    public static void main(String[] args) {
        // loop through files
        for (String filename: args) {
            ErrorHandler errorHandler = new ErrorHandler();
            Parser parser = new Parser(errorHandler);
            try {
                Program root = parser.parse(filename);
                System.out.println(String.format(
                        "Parsing was successful for %s", filename));
                Drawer drawer = new Drawer();
                drawer.draw(filename, root);
            } catch (CompilationException ex) {
                for (Error error : errorHandler.getErrorList()) {
                    System.out.println(error.toString());
                    ex.printStackTrace();
                }
            }
        }
    }
}
